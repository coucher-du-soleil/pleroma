// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protoloma.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protoloma_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protoloma_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protoloma_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protoloma_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protoloma_2eproto;
namespace romabuf {
class AnnouncePeer;
class AnnouncePeerDefaultTypeInternal;
extern AnnouncePeerDefaultTypeInternal _AnnouncePeer_default_instance_;
class AssignClusterInfo;
class AssignClusterInfoDefaultTypeInternal;
extern AssignClusterInfoDefaultTypeInternal _AssignClusterInfo_default_instance_;
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class ERefVal;
class ERefValDefaultTypeInternal;
extern ERefValDefaultTypeInternal _ERefVal_default_instance_;
class Greeting;
class GreetingDefaultTypeInternal;
extern GreetingDefaultTypeInternal _Greeting_default_instance_;
class GreetingAck;
class GreetingAckDefaultTypeInternal;
extern GreetingAckDefaultTypeInternal _GreetingAck_default_instance_;
class HostInfo;
class HostInfoDefaultTypeInternal;
extern HostInfoDefaultTypeInternal _HostInfo_default_instance_;
class LoadProgram;
class LoadProgramDefaultTypeInternal;
extern LoadProgramDefaultTypeInternal _LoadProgram_default_instance_;
class NumVal;
class NumValDefaultTypeInternal;
extern NumValDefaultTypeInternal _NumVal_default_instance_;
class PValue;
class PValueDefaultTypeInternal;
extern PValueDefaultTypeInternal _PValue_default_instance_;
class PleromaMessage;
class PleromaMessageDefaultTypeInternal;
extern PleromaMessageDefaultTypeInternal _PleromaMessage_default_instance_;
class StrVal;
class StrValDefaultTypeInternal;
extern StrValDefaultTypeInternal _StrVal_default_instance_;
}  // namespace romabuf
PROTOBUF_NAMESPACE_OPEN
template<> ::romabuf::AnnouncePeer* Arena::CreateMaybeMessage<::romabuf::AnnouncePeer>(Arena*);
template<> ::romabuf::AssignClusterInfo* Arena::CreateMaybeMessage<::romabuf::AssignClusterInfo>(Arena*);
template<> ::romabuf::Call* Arena::CreateMaybeMessage<::romabuf::Call>(Arena*);
template<> ::romabuf::ERefVal* Arena::CreateMaybeMessage<::romabuf::ERefVal>(Arena*);
template<> ::romabuf::Greeting* Arena::CreateMaybeMessage<::romabuf::Greeting>(Arena*);
template<> ::romabuf::GreetingAck* Arena::CreateMaybeMessage<::romabuf::GreetingAck>(Arena*);
template<> ::romabuf::HostInfo* Arena::CreateMaybeMessage<::romabuf::HostInfo>(Arena*);
template<> ::romabuf::LoadProgram* Arena::CreateMaybeMessage<::romabuf::LoadProgram>(Arena*);
template<> ::romabuf::NumVal* Arena::CreateMaybeMessage<::romabuf::NumVal>(Arena*);
template<> ::romabuf::PValue* Arena::CreateMaybeMessage<::romabuf::PValue>(Arena*);
template<> ::romabuf::PleromaMessage* Arena::CreateMaybeMessage<::romabuf::PleromaMessage>(Arena*);
template<> ::romabuf::StrVal* Arena::CreateMaybeMessage<::romabuf::StrVal>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace romabuf {

// ===================================================================

class HostInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.HostInfo) */ {
 public:
  inline HostInfo() : HostInfo(nullptr) {};
  virtual ~HostInfo();

  HostInfo(const HostInfo& from);
  HostInfo(HostInfo&& from) noexcept
    : HostInfo() {
    *this = ::std::move(from);
  }

  inline HostInfo& operator=(const HostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostInfo& operator=(HostInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HostInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostInfo* internal_default_instance() {
    return reinterpret_cast<const HostInfo*>(
               &_HostInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HostInfo& a, HostInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(HostInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HostInfo* New() const final {
    return CreateMaybeMessage<HostInfo>(nullptr);
  }

  HostInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HostInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HostInfo& from);
  void MergeFrom(const HostInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.HostInfo";
  }
  protected:
  explicit HostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 5,
    kAddressFieldNumber = 2,
    kNodemanAddrFieldNumber = 4,
    kNodeIdFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // repeated string resources = 5;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  const std::string& resources(int index) const;
  std::string* mutable_resources(int index);
  void set_resources(int index, const std::string& value);
  void set_resources(int index, std::string&& value);
  void set_resources(int index, const char* value);
  void set_resources(int index, const char* value, size_t size);
  std::string* add_resources();
  void add_resources(const std::string& value);
  void add_resources(std::string&& value);
  void add_resources(const char* value);
  void add_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resources();
  private:
  const std::string& _internal_resources(int index) const;
  std::string* _internal_add_resources();
  public:

  // required string address = 2;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_address(
      std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required .romabuf.ERefVal nodeman_addr = 4;
  bool has_nodeman_addr() const;
  private:
  bool _internal_has_nodeman_addr() const;
  public:
  void clear_nodeman_addr();
  const ::romabuf::ERefVal& nodeman_addr() const;
  ::romabuf::ERefVal* release_nodeman_addr();
  ::romabuf::ERefVal* mutable_nodeman_addr();
  void set_allocated_nodeman_addr(::romabuf::ERefVal* nodeman_addr);
  private:
  const ::romabuf::ERefVal& _internal_nodeman_addr() const;
  ::romabuf::ERefVal* _internal_mutable_nodeman_addr();
  public:
  void unsafe_arena_set_allocated_nodeman_addr(
      ::romabuf::ERefVal* nodeman_addr);
  ::romabuf::ERefVal* unsafe_arena_release_nodeman_addr();

  // required int32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.HostInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::romabuf::ERefVal* nodeman_addr_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class NumVal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.NumVal) */ {
 public:
  inline NumVal() : NumVal(nullptr) {};
  virtual ~NumVal();

  NumVal(const NumVal& from);
  NumVal(NumVal&& from) noexcept
    : NumVal() {
    *this = ::std::move(from);
  }

  inline NumVal& operator=(const NumVal& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumVal& operator=(NumVal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NumVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumVal* internal_default_instance() {
    return reinterpret_cast<const NumVal*>(
               &_NumVal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NumVal& a, NumVal& b) {
    a.Swap(&b);
  }
  inline void Swap(NumVal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumVal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumVal* New() const final {
    return CreateMaybeMessage<NumVal>(nullptr);
  }

  NumVal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumVal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NumVal& from);
  void MergeFrom(const NumVal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumVal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.NumVal";
  }
  protected:
  explicit NumVal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required int32 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.NumVal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class StrVal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.StrVal) */ {
 public:
  inline StrVal() : StrVal(nullptr) {};
  virtual ~StrVal();

  StrVal(const StrVal& from);
  StrVal(StrVal&& from) noexcept
    : StrVal() {
    *this = ::std::move(from);
  }

  inline StrVal& operator=(const StrVal& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrVal& operator=(StrVal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StrVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrVal* internal_default_instance() {
    return reinterpret_cast<const StrVal*>(
               &_StrVal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StrVal& a, StrVal& b) {
    a.Swap(&b);
  }
  inline void Swap(StrVal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrVal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrVal* New() const final {
    return CreateMaybeMessage<StrVal>(nullptr);
  }

  StrVal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrVal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrVal& from);
  void MergeFrom(const StrVal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrVal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.StrVal";
  }
  protected:
  explicit StrVal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:romabuf.StrVal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class ERefVal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.ERefVal) */ {
 public:
  inline ERefVal() : ERefVal(nullptr) {};
  virtual ~ERefVal();

  ERefVal(const ERefVal& from);
  ERefVal(ERefVal&& from) noexcept
    : ERefVal() {
    *this = ::std::move(from);
  }

  inline ERefVal& operator=(const ERefVal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ERefVal& operator=(ERefVal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ERefVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ERefVal* internal_default_instance() {
    return reinterpret_cast<const ERefVal*>(
               &_ERefVal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ERefVal& a, ERefVal& b) {
    a.Swap(&b);
  }
  inline void Swap(ERefVal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ERefVal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ERefVal* New() const final {
    return CreateMaybeMessage<ERefVal>(nullptr);
  }

  ERefVal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ERefVal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ERefVal& from);
  void MergeFrom(const ERefVal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ERefVal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.ERefVal";
  }
  protected:
  explicit ERefVal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kVatIdFieldNumber = 2,
    kEntityIdFieldNumber = 3,
  };
  // required int32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 vat_id = 2;
  bool has_vat_id() const;
  private:
  bool _internal_has_vat_id() const;
  public:
  void clear_vat_id();
  ::PROTOBUF_NAMESPACE_ID::int32 vat_id() const;
  void set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vat_id() const;
  void _internal_set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 entity_id = 3;
  bool has_entity_id() const;
  private:
  bool _internal_has_entity_id() const;
  public:
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.ERefVal)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 vat_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class PValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.PValue) */ {
 public:
  inline PValue() : PValue(nullptr) {};
  virtual ~PValue();

  PValue(const PValue& from);
  PValue(PValue&& from) noexcept
    : PValue() {
    *this = ::std::move(from);
  }

  inline PValue& operator=(const PValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PValue& operator=(PValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PValue& default_instance();

  enum ValueCase {
    kNumVal = 1,
    kStrVal = 2,
    kErefVal = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PValue* internal_default_instance() {
    return reinterpret_cast<const PValue*>(
               &_PValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PValue& a, PValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PValue* New() const final {
    return CreateMaybeMessage<PValue>(nullptr);
  }

  PValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PValue& from);
  void MergeFrom(const PValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.PValue";
  }
  protected:
  explicit PValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumValFieldNumber = 1,
    kStrValFieldNumber = 2,
    kErefValFieldNumber = 3,
  };
  // .romabuf.NumVal num_val = 1;
  bool has_num_val() const;
  private:
  bool _internal_has_num_val() const;
  public:
  void clear_num_val();
  const ::romabuf::NumVal& num_val() const;
  ::romabuf::NumVal* release_num_val();
  ::romabuf::NumVal* mutable_num_val();
  void set_allocated_num_val(::romabuf::NumVal* num_val);
  private:
  const ::romabuf::NumVal& _internal_num_val() const;
  ::romabuf::NumVal* _internal_mutable_num_val();
  public:
  void unsafe_arena_set_allocated_num_val(
      ::romabuf::NumVal* num_val);
  ::romabuf::NumVal* unsafe_arena_release_num_val();

  // .romabuf.StrVal str_val = 2;
  bool has_str_val() const;
  private:
  bool _internal_has_str_val() const;
  public:
  void clear_str_val();
  const ::romabuf::StrVal& str_val() const;
  ::romabuf::StrVal* release_str_val();
  ::romabuf::StrVal* mutable_str_val();
  void set_allocated_str_val(::romabuf::StrVal* str_val);
  private:
  const ::romabuf::StrVal& _internal_str_val() const;
  ::romabuf::StrVal* _internal_mutable_str_val();
  public:
  void unsafe_arena_set_allocated_str_val(
      ::romabuf::StrVal* str_val);
  ::romabuf::StrVal* unsafe_arena_release_str_val();

  // .romabuf.ERefVal eref_val = 3;
  bool has_eref_val() const;
  private:
  bool _internal_has_eref_val() const;
  public:
  void clear_eref_val();
  const ::romabuf::ERefVal& eref_val() const;
  ::romabuf::ERefVal* release_eref_val();
  ::romabuf::ERefVal* mutable_eref_val();
  void set_allocated_eref_val(::romabuf::ERefVal* eref_val);
  private:
  const ::romabuf::ERefVal& _internal_eref_val() const;
  ::romabuf::ERefVal* _internal_mutable_eref_val();
  public:
  void unsafe_arena_set_allocated_eref_val(
      ::romabuf::ERefVal* eref_val);
  ::romabuf::ERefVal* unsafe_arena_release_eref_val();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:romabuf.PValue)
 private:
  class _Internal;
  void set_has_num_val();
  void set_has_str_val();
  void set_has_eref_val();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::romabuf::NumVal* num_val_;
    ::romabuf::StrVal* str_val_;
    ::romabuf::ERefVal* eref_val_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class PleromaMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.PleromaMessage) */ {
 public:
  inline PleromaMessage() : PleromaMessage(nullptr) {};
  virtual ~PleromaMessage();

  PleromaMessage(const PleromaMessage& from);
  PleromaMessage(PleromaMessage&& from) noexcept
    : PleromaMessage() {
    *this = ::std::move(from);
  }

  inline PleromaMessage& operator=(const PleromaMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PleromaMessage& operator=(PleromaMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PleromaMessage& default_instance();

  enum MsgCase {
    kCall = 1,
    kAnnouncePeer = 2,
    kAssignClusterInfo = 3,
    kHostInfo = 4,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PleromaMessage* internal_default_instance() {
    return reinterpret_cast<const PleromaMessage*>(
               &_PleromaMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PleromaMessage& a, PleromaMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PleromaMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PleromaMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PleromaMessage* New() const final {
    return CreateMaybeMessage<PleromaMessage>(nullptr);
  }

  PleromaMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PleromaMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PleromaMessage& from);
  void MergeFrom(const PleromaMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PleromaMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.PleromaMessage";
  }
  protected:
  explicit PleromaMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallFieldNumber = 1,
    kAnnouncePeerFieldNumber = 2,
    kAssignClusterInfoFieldNumber = 3,
    kHostInfoFieldNumber = 4,
  };
  // .romabuf.Call call = 1;
  bool has_call() const;
  private:
  bool _internal_has_call() const;
  public:
  void clear_call();
  const ::romabuf::Call& call() const;
  ::romabuf::Call* release_call();
  ::romabuf::Call* mutable_call();
  void set_allocated_call(::romabuf::Call* call);
  private:
  const ::romabuf::Call& _internal_call() const;
  ::romabuf::Call* _internal_mutable_call();
  public:
  void unsafe_arena_set_allocated_call(
      ::romabuf::Call* call);
  ::romabuf::Call* unsafe_arena_release_call();

  // .romabuf.AnnouncePeer announce_peer = 2;
  bool has_announce_peer() const;
  private:
  bool _internal_has_announce_peer() const;
  public:
  void clear_announce_peer();
  const ::romabuf::AnnouncePeer& announce_peer() const;
  ::romabuf::AnnouncePeer* release_announce_peer();
  ::romabuf::AnnouncePeer* mutable_announce_peer();
  void set_allocated_announce_peer(::romabuf::AnnouncePeer* announce_peer);
  private:
  const ::romabuf::AnnouncePeer& _internal_announce_peer() const;
  ::romabuf::AnnouncePeer* _internal_mutable_announce_peer();
  public:
  void unsafe_arena_set_allocated_announce_peer(
      ::romabuf::AnnouncePeer* announce_peer);
  ::romabuf::AnnouncePeer* unsafe_arena_release_announce_peer();

  // .romabuf.AssignClusterInfo assign_cluster_info = 3;
  bool has_assign_cluster_info() const;
  private:
  bool _internal_has_assign_cluster_info() const;
  public:
  void clear_assign_cluster_info();
  const ::romabuf::AssignClusterInfo& assign_cluster_info() const;
  ::romabuf::AssignClusterInfo* release_assign_cluster_info();
  ::romabuf::AssignClusterInfo* mutable_assign_cluster_info();
  void set_allocated_assign_cluster_info(::romabuf::AssignClusterInfo* assign_cluster_info);
  private:
  const ::romabuf::AssignClusterInfo& _internal_assign_cluster_info() const;
  ::romabuf::AssignClusterInfo* _internal_mutable_assign_cluster_info();
  public:
  void unsafe_arena_set_allocated_assign_cluster_info(
      ::romabuf::AssignClusterInfo* assign_cluster_info);
  ::romabuf::AssignClusterInfo* unsafe_arena_release_assign_cluster_info();

  // .romabuf.HostInfo host_info = 4;
  bool has_host_info() const;
  private:
  bool _internal_has_host_info() const;
  public:
  void clear_host_info();
  const ::romabuf::HostInfo& host_info() const;
  ::romabuf::HostInfo* release_host_info();
  ::romabuf::HostInfo* mutable_host_info();
  void set_allocated_host_info(::romabuf::HostInfo* host_info);
  private:
  const ::romabuf::HostInfo& _internal_host_info() const;
  ::romabuf::HostInfo* _internal_mutable_host_info();
  public:
  void unsafe_arena_set_allocated_host_info(
      ::romabuf::HostInfo* host_info);
  ::romabuf::HostInfo* unsafe_arena_release_host_info();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:romabuf.PleromaMessage)
 private:
  class _Internal;
  void set_has_call();
  void set_has_announce_peer();
  void set_has_assign_cluster_info();
  void set_has_host_info();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MsgUnion {
    MsgUnion() {}
    ::romabuf::Call* call_;
    ::romabuf::AnnouncePeer* announce_peer_;
    ::romabuf::AssignClusterInfo* assign_cluster_info_;
    ::romabuf::HostInfo* host_info_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class Call PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.Call) */ {
 public:
  inline Call() : Call(nullptr) {};
  virtual ~Call();

  Call(const Call& from);
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline Call& operator=(Call&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }
  inline void Swap(Call* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const final {
    return CreateMaybeMessage<Call>(nullptr);
  }

  Call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Call>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Call* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.Call";
  }
  protected:
  explicit Call(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPvaluesFieldNumber = 11,
    kFunctionIdFieldNumber = 4,
    kSrcFunctionIdFieldNumber = 8,
    kNodeIdFieldNumber = 1,
    kVatIdFieldNumber = 2,
    kEntityIdFieldNumber = 3,
    kSrcNodeIdFieldNumber = 5,
    kSrcVatIdFieldNumber = 6,
    kSrcEntityIdFieldNumber = 7,
    kResponseFieldNumber = 9,
    kPromiseIdFieldNumber = 10,
  };
  // repeated .romabuf.PValue pvalues = 11;
  int pvalues_size() const;
  private:
  int _internal_pvalues_size() const;
  public:
  void clear_pvalues();
  ::romabuf::PValue* mutable_pvalues(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::PValue >*
      mutable_pvalues();
  private:
  const ::romabuf::PValue& _internal_pvalues(int index) const;
  ::romabuf::PValue* _internal_add_pvalues();
  public:
  const ::romabuf::PValue& pvalues(int index) const;
  ::romabuf::PValue* add_pvalues();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::PValue >&
      pvalues() const;

  // required string function_id = 4;
  bool has_function_id() const;
  private:
  bool _internal_has_function_id() const;
  public:
  void clear_function_id();
  const std::string& function_id() const;
  void set_function_id(const std::string& value);
  void set_function_id(std::string&& value);
  void set_function_id(const char* value);
  void set_function_id(const char* value, size_t size);
  std::string* mutable_function_id();
  std::string* release_function_id();
  void set_allocated_function_id(std::string* function_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_function_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_function_id(
      std::string* function_id);
  private:
  const std::string& _internal_function_id() const;
  void _internal_set_function_id(const std::string& value);
  std::string* _internal_mutable_function_id();
  public:

  // required string src_function_id = 8;
  bool has_src_function_id() const;
  private:
  bool _internal_has_src_function_id() const;
  public:
  void clear_src_function_id();
  const std::string& src_function_id() const;
  void set_src_function_id(const std::string& value);
  void set_src_function_id(std::string&& value);
  void set_src_function_id(const char* value);
  void set_src_function_id(const char* value, size_t size);
  std::string* mutable_src_function_id();
  std::string* release_src_function_id();
  void set_allocated_src_function_id(std::string* src_function_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_src_function_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_src_function_id(
      std::string* src_function_id);
  private:
  const std::string& _internal_src_function_id() const;
  void _internal_set_src_function_id(const std::string& value);
  std::string* _internal_mutable_src_function_id();
  public:

  // required int32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 vat_id = 2;
  bool has_vat_id() const;
  private:
  bool _internal_has_vat_id() const;
  public:
  void clear_vat_id();
  ::PROTOBUF_NAMESPACE_ID::int32 vat_id() const;
  void set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vat_id() const;
  void _internal_set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 entity_id = 3;
  bool has_entity_id() const;
  private:
  bool _internal_has_entity_id() const;
  public:
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 src_node_id = 5;
  bool has_src_node_id() const;
  private:
  bool _internal_has_src_node_id() const;
  public:
  void clear_src_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 src_node_id() const;
  void set_src_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_node_id() const;
  void _internal_set_src_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 src_vat_id = 6;
  bool has_src_vat_id() const;
  private:
  bool _internal_has_src_vat_id() const;
  public:
  void clear_src_vat_id();
  ::PROTOBUF_NAMESPACE_ID::int32 src_vat_id() const;
  void set_src_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_vat_id() const;
  void _internal_set_src_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 src_entity_id = 7;
  bool has_src_entity_id() const;
  private:
  bool _internal_has_src_entity_id() const;
  public:
  void clear_src_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 src_entity_id() const;
  void set_src_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_src_entity_id() const;
  void _internal_set_src_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool response = 9;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  bool response() const;
  void set_response(bool value);
  private:
  bool _internal_response() const;
  void _internal_set_response(bool value);
  public:

  // required int32 promise_id = 10;
  bool has_promise_id() const;
  private:
  bool _internal_has_promise_id() const;
  public:
  void clear_promise_id();
  ::PROTOBUF_NAMESPACE_ID::int32 promise_id() const;
  void set_promise_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_promise_id() const;
  void _internal_set_promise_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.Call)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::PValue > pvalues_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_function_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 vat_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_vat_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 src_entity_id_;
  bool response_;
  ::PROTOBUF_NAMESPACE_ID::int32 promise_id_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class AnnouncePeer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.AnnouncePeer) */ {
 public:
  inline AnnouncePeer() : AnnouncePeer(nullptr) {};
  virtual ~AnnouncePeer();

  AnnouncePeer(const AnnouncePeer& from);
  AnnouncePeer(AnnouncePeer&& from) noexcept
    : AnnouncePeer() {
    *this = ::std::move(from);
  }

  inline AnnouncePeer& operator=(const AnnouncePeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnouncePeer& operator=(AnnouncePeer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnnouncePeer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnouncePeer* internal_default_instance() {
    return reinterpret_cast<const AnnouncePeer*>(
               &_AnnouncePeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AnnouncePeer& a, AnnouncePeer& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnouncePeer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnouncePeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnnouncePeer* New() const final {
    return CreateMaybeMessage<AnnouncePeer>(nullptr);
  }

  AnnouncePeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnnouncePeer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnnouncePeer& from);
  void MergeFrom(const AnnouncePeer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnouncePeer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.AnnouncePeer";
  }
  protected:
  explicit AnnouncePeer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // required string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_address(
      std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.AnnouncePeer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class AssignClusterInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.AssignClusterInfo) */ {
 public:
  inline AssignClusterInfo() : AssignClusterInfo(nullptr) {};
  virtual ~AssignClusterInfo();

  AssignClusterInfo(const AssignClusterInfo& from);
  AssignClusterInfo(AssignClusterInfo&& from) noexcept
    : AssignClusterInfo() {
    *this = ::std::move(from);
  }

  inline AssignClusterInfo& operator=(const AssignClusterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssignClusterInfo& operator=(AssignClusterInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AssignClusterInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignClusterInfo* internal_default_instance() {
    return reinterpret_cast<const AssignClusterInfo*>(
               &_AssignClusterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AssignClusterInfo& a, AssignClusterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AssignClusterInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssignClusterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AssignClusterInfo* New() const final {
    return CreateMaybeMessage<AssignClusterInfo>(nullptr);
  }

  AssignClusterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AssignClusterInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AssignClusterInfo& from);
  void MergeFrom(const AssignClusterInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignClusterInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.AssignClusterInfo";
  }
  protected:
  explicit AssignClusterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 5,
    kNodeIdFieldNumber = 1,
    kMonadNodeIdFieldNumber = 2,
    kMonadVatIdFieldNumber = 3,
    kMonadEntityIdFieldNumber = 4,
  };
  // repeated .romabuf.HostInfo nodes = 5;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::romabuf::HostInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::HostInfo >*
      mutable_nodes();
  private:
  const ::romabuf::HostInfo& _internal_nodes(int index) const;
  ::romabuf::HostInfo* _internal_add_nodes();
  public:
  const ::romabuf::HostInfo& nodes(int index) const;
  ::romabuf::HostInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::HostInfo >&
      nodes() const;

  // required uint32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int32 monad_node_id = 2;
  bool has_monad_node_id() const;
  private:
  bool _internal_has_monad_node_id() const;
  public:
  void clear_monad_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 monad_node_id() const;
  void set_monad_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_monad_node_id() const;
  void _internal_set_monad_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 monad_vat_id = 3;
  bool has_monad_vat_id() const;
  private:
  bool _internal_has_monad_vat_id() const;
  public:
  void clear_monad_vat_id();
  ::PROTOBUF_NAMESPACE_ID::int32 monad_vat_id() const;
  void set_monad_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_monad_vat_id() const;
  void _internal_set_monad_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 monad_entity_id = 4;
  bool has_monad_entity_id() const;
  private:
  bool _internal_has_monad_entity_id() const;
  public:
  void clear_monad_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 monad_entity_id() const;
  void set_monad_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_monad_entity_id() const;
  void _internal_set_monad_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.AssignClusterInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::HostInfo > nodes_;
  ::PROTOBUF_NAMESPACE_ID::uint32 node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 monad_node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 monad_vat_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 monad_entity_id_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class Greeting PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.Greeting) */ {
 public:
  inline Greeting() : Greeting(nullptr) {};
  virtual ~Greeting();

  Greeting(const Greeting& from);
  Greeting(Greeting&& from) noexcept
    : Greeting() {
    *this = ::std::move(from);
  }

  inline Greeting& operator=(const Greeting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Greeting& operator=(Greeting&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Greeting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Greeting* internal_default_instance() {
    return reinterpret_cast<const Greeting*>(
               &_Greeting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Greeting& a, Greeting& b) {
    a.Swap(&b);
  }
  inline void Swap(Greeting* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Greeting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Greeting* New() const final {
    return CreateMaybeMessage<Greeting>(nullptr);
  }

  Greeting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Greeting>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Greeting& from);
  void MergeFrom(const Greeting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Greeting* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.Greeting";
  }
  protected:
  explicit Greeting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeNameFieldNumber = 1,
  };
  // required string node_name = 1;
  bool has_node_name() const;
  private:
  bool _internal_has_node_name() const;
  public:
  void clear_node_name();
  const std::string& node_name() const;
  void set_node_name(const std::string& value);
  void set_node_name(std::string&& value);
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  std::string* mutable_node_name();
  std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_node_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_node_name(
      std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // @@protoc_insertion_point(class_scope:romabuf.Greeting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class GreetingAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.GreetingAck) */ {
 public:
  inline GreetingAck() : GreetingAck(nullptr) {};
  virtual ~GreetingAck();

  GreetingAck(const GreetingAck& from);
  GreetingAck(GreetingAck&& from) noexcept
    : GreetingAck() {
    *this = ::std::move(from);
  }

  inline GreetingAck& operator=(const GreetingAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreetingAck& operator=(GreetingAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GreetingAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GreetingAck* internal_default_instance() {
    return reinterpret_cast<const GreetingAck*>(
               &_GreetingAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GreetingAck& a, GreetingAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GreetingAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreetingAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GreetingAck* New() const final {
    return CreateMaybeMessage<GreetingAck>(nullptr);
  }

  GreetingAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GreetingAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GreetingAck& from);
  void MergeFrom(const GreetingAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreetingAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.GreetingAck";
  }
  protected:
  explicit GreetingAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
  };
  // required int32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:romabuf.GreetingAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// -------------------------------------------------------------------

class LoadProgram PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:romabuf.LoadProgram) */ {
 public:
  inline LoadProgram() : LoadProgram(nullptr) {};
  virtual ~LoadProgram();

  LoadProgram(const LoadProgram& from);
  LoadProgram(LoadProgram&& from) noexcept
    : LoadProgram() {
    *this = ::std::move(from);
  }

  inline LoadProgram& operator=(const LoadProgram& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadProgram& operator=(LoadProgram&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadProgram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadProgram* internal_default_instance() {
    return reinterpret_cast<const LoadProgram*>(
               &_LoadProgram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoadProgram& a, LoadProgram& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadProgram* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadProgram* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadProgram* New() const final {
    return CreateMaybeMessage<LoadProgram>(nullptr);
  }

  LoadProgram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadProgram>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadProgram& from);
  void MergeFrom(const LoadProgram& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadProgram* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "romabuf.LoadProgram";
  }
  protected:
  explicit LoadProgram(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protoloma_2eproto);
    return ::descriptor_table_protoloma_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:romabuf.LoadProgram)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protoloma_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HostInfo

// required int32 node_id = 1;
inline bool HostInfo::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HostInfo::has_node_id() const {
  return _internal_has_node_id();
}
inline void HostInfo::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HostInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HostInfo::node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.HostInfo.node_id)
  return _internal_node_id();
}
inline void HostInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_id_ = value;
}
inline void HostInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.HostInfo.node_id)
}

// required string address = 2;
inline bool HostInfo::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HostInfo::has_address() const {
  return _internal_has_address();
}
inline void HostInfo::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostInfo::address() const {
  // @@protoc_insertion_point(field_get:romabuf.HostInfo.address)
  return _internal_address();
}
inline void HostInfo::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:romabuf.HostInfo.address)
}
inline std::string* HostInfo::mutable_address() {
  // @@protoc_insertion_point(field_mutable:romabuf.HostInfo.address)
  return _internal_mutable_address();
}
inline const std::string& HostInfo::_internal_address() const {
  return address_.Get();
}
inline void HostInfo::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HostInfo::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.HostInfo.address)
}
inline void HostInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.HostInfo.address)
}
inline void HostInfo::set_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.HostInfo.address)
}
inline std::string* HostInfo::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HostInfo::release_address() {
  // @@protoc_insertion_point(field_release:romabuf.HostInfo.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HostInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.HostInfo.address)
}
inline std::string* HostInfo::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.HostInfo.address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HostInfo::unsafe_arena_set_allocated_address(
    std::string* address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.HostInfo.address)
}

// required uint32 port = 3;
inline bool HostInfo::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HostInfo::has_port() const {
  return _internal_has_port();
}
inline void HostInfo::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HostInfo::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HostInfo::port() const {
  // @@protoc_insertion_point(field_get:romabuf.HostInfo.port)
  return _internal_port();
}
inline void HostInfo::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  port_ = value;
}
inline void HostInfo::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:romabuf.HostInfo.port)
}

// required .romabuf.ERefVal nodeman_addr = 4;
inline bool HostInfo::_internal_has_nodeman_addr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || nodeman_addr_ != nullptr);
  return value;
}
inline bool HostInfo::has_nodeman_addr() const {
  return _internal_has_nodeman_addr();
}
inline void HostInfo::clear_nodeman_addr() {
  if (nodeman_addr_ != nullptr) nodeman_addr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::romabuf::ERefVal& HostInfo::_internal_nodeman_addr() const {
  const ::romabuf::ERefVal* p = nodeman_addr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::romabuf::ERefVal*>(
      &::romabuf::_ERefVal_default_instance_);
}
inline const ::romabuf::ERefVal& HostInfo::nodeman_addr() const {
  // @@protoc_insertion_point(field_get:romabuf.HostInfo.nodeman_addr)
  return _internal_nodeman_addr();
}
inline void HostInfo::unsafe_arena_set_allocated_nodeman_addr(
    ::romabuf::ERefVal* nodeman_addr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodeman_addr_);
  }
  nodeman_addr_ = nodeman_addr;
  if (nodeman_addr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.HostInfo.nodeman_addr)
}
inline ::romabuf::ERefVal* HostInfo::release_nodeman_addr() {
  auto temp = unsafe_arena_release_nodeman_addr();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::romabuf::ERefVal* HostInfo::unsafe_arena_release_nodeman_addr() {
  // @@protoc_insertion_point(field_release:romabuf.HostInfo.nodeman_addr)
  _has_bits_[0] &= ~0x00000002u;
  ::romabuf::ERefVal* temp = nodeman_addr_;
  nodeman_addr_ = nullptr;
  return temp;
}
inline ::romabuf::ERefVal* HostInfo::_internal_mutable_nodeman_addr() {
  _has_bits_[0] |= 0x00000002u;
  if (nodeman_addr_ == nullptr) {
    auto* p = CreateMaybeMessage<::romabuf::ERefVal>(GetArena());
    nodeman_addr_ = p;
  }
  return nodeman_addr_;
}
inline ::romabuf::ERefVal* HostInfo::mutable_nodeman_addr() {
  // @@protoc_insertion_point(field_mutable:romabuf.HostInfo.nodeman_addr)
  return _internal_mutable_nodeman_addr();
}
inline void HostInfo::set_allocated_nodeman_addr(::romabuf::ERefVal* nodeman_addr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nodeman_addr_;
  }
  if (nodeman_addr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nodeman_addr);
    if (message_arena != submessage_arena) {
      nodeman_addr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodeman_addr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodeman_addr_ = nodeman_addr;
  // @@protoc_insertion_point(field_set_allocated:romabuf.HostInfo.nodeman_addr)
}

// repeated string resources = 5;
inline int HostInfo::_internal_resources_size() const {
  return resources_.size();
}
inline int HostInfo::resources_size() const {
  return _internal_resources_size();
}
inline void HostInfo::clear_resources() {
  resources_.Clear();
}
inline std::string* HostInfo::add_resources() {
  // @@protoc_insertion_point(field_add_mutable:romabuf.HostInfo.resources)
  return _internal_add_resources();
}
inline const std::string& HostInfo::_internal_resources(int index) const {
  return resources_.Get(index);
}
inline const std::string& HostInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:romabuf.HostInfo.resources)
  return _internal_resources(index);
}
inline std::string* HostInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:romabuf.HostInfo.resources)
  return resources_.Mutable(index);
}
inline void HostInfo::set_resources(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:romabuf.HostInfo.resources)
  resources_.Mutable(index)->assign(value);
}
inline void HostInfo::set_resources(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:romabuf.HostInfo.resources)
  resources_.Mutable(index)->assign(std::move(value));
}
inline void HostInfo::set_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:romabuf.HostInfo.resources)
}
inline void HostInfo::set_resources(int index, const char* value, size_t size) {
  resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:romabuf.HostInfo.resources)
}
inline std::string* HostInfo::_internal_add_resources() {
  return resources_.Add();
}
inline void HostInfo::add_resources(const std::string& value) {
  resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:romabuf.HostInfo.resources)
}
inline void HostInfo::add_resources(std::string&& value) {
  resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:romabuf.HostInfo.resources)
}
inline void HostInfo::add_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:romabuf.HostInfo.resources)
}
inline void HostInfo::add_resources(const char* value, size_t size) {
  resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:romabuf.HostInfo.resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HostInfo::resources() const {
  // @@protoc_insertion_point(field_list:romabuf.HostInfo.resources)
  return resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HostInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:romabuf.HostInfo.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// NumVal

// required int32 value = 1;
inline bool NumVal::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NumVal::has_value() const {
  return _internal_has_value();
}
inline void NumVal::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NumVal::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NumVal::value() const {
  // @@protoc_insertion_point(field_get:romabuf.NumVal.value)
  return _internal_value();
}
inline void NumVal::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void NumVal::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:romabuf.NumVal.value)
}

// -------------------------------------------------------------------

// StrVal

// required string value = 1;
inline bool StrVal::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrVal::has_value() const {
  return _internal_has_value();
}
inline void StrVal::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StrVal::value() const {
  // @@protoc_insertion_point(field_get:romabuf.StrVal.value)
  return _internal_value();
}
inline void StrVal::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:romabuf.StrVal.value)
}
inline std::string* StrVal::mutable_value() {
  // @@protoc_insertion_point(field_mutable:romabuf.StrVal.value)
  return _internal_mutable_value();
}
inline const std::string& StrVal::_internal_value() const {
  return value_.Get();
}
inline void StrVal::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StrVal::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.StrVal.value)
}
inline void StrVal::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.StrVal.value)
}
inline void StrVal::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.StrVal.value)
}
inline std::string* StrVal::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StrVal::release_value() {
  // @@protoc_insertion_point(field_release:romabuf.StrVal.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StrVal::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.StrVal.value)
}
inline std::string* StrVal::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.StrVal.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StrVal::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.StrVal.value)
}

// -------------------------------------------------------------------

// ERefVal

// required int32 node_id = 1;
inline bool ERefVal::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ERefVal::has_node_id() const {
  return _internal_has_node_id();
}
inline void ERefVal::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.ERefVal.node_id)
  return _internal_node_id();
}
inline void ERefVal::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_ = value;
}
inline void ERefVal::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.ERefVal.node_id)
}

// required int32 vat_id = 2;
inline bool ERefVal::_internal_has_vat_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ERefVal::has_vat_id() const {
  return _internal_has_vat_id();
}
inline void ERefVal::clear_vat_id() {
  vat_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::_internal_vat_id() const {
  return vat_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::vat_id() const {
  // @@protoc_insertion_point(field_get:romabuf.ERefVal.vat_id)
  return _internal_vat_id();
}
inline void ERefVal::_internal_set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  vat_id_ = value;
}
inline void ERefVal::set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vat_id(value);
  // @@protoc_insertion_point(field_set:romabuf.ERefVal.vat_id)
}

// required int32 entity_id = 3;
inline bool ERefVal::_internal_has_entity_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ERefVal::has_entity_id() const {
  return _internal_has_entity_id();
}
inline void ERefVal::clear_entity_id() {
  entity_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ERefVal::entity_id() const {
  // @@protoc_insertion_point(field_get:romabuf.ERefVal.entity_id)
  return _internal_entity_id();
}
inline void ERefVal::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  entity_id_ = value;
}
inline void ERefVal::set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:romabuf.ERefVal.entity_id)
}

// -------------------------------------------------------------------

// PValue

// .romabuf.NumVal num_val = 1;
inline bool PValue::_internal_has_num_val() const {
  return value_case() == kNumVal;
}
inline bool PValue::has_num_val() const {
  return _internal_has_num_val();
}
inline void PValue::set_has_num_val() {
  _oneof_case_[0] = kNumVal;
}
inline void PValue::clear_num_val() {
  if (_internal_has_num_val()) {
    if (GetArena() == nullptr) {
      delete value_.num_val_;
    }
    clear_has_value();
  }
}
inline ::romabuf::NumVal* PValue::release_num_val() {
  // @@protoc_insertion_point(field_release:romabuf.PValue.num_val)
  if (_internal_has_num_val()) {
    clear_has_value();
      ::romabuf::NumVal* temp = value_.num_val_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.num_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::NumVal& PValue::_internal_num_val() const {
  return _internal_has_num_val()
      ? *value_.num_val_
      : *reinterpret_cast< ::romabuf::NumVal*>(&::romabuf::_NumVal_default_instance_);
}
inline const ::romabuf::NumVal& PValue::num_val() const {
  // @@protoc_insertion_point(field_get:romabuf.PValue.num_val)
  return _internal_num_val();
}
inline ::romabuf::NumVal* PValue::unsafe_arena_release_num_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PValue.num_val)
  if (_internal_has_num_val()) {
    clear_has_value();
    ::romabuf::NumVal* temp = value_.num_val_;
    value_.num_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PValue::unsafe_arena_set_allocated_num_val(::romabuf::NumVal* num_val) {
  clear_value();
  if (num_val) {
    set_has_num_val();
    value_.num_val_ = num_val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PValue.num_val)
}
inline ::romabuf::NumVal* PValue::_internal_mutable_num_val() {
  if (!_internal_has_num_val()) {
    clear_value();
    set_has_num_val();
    value_.num_val_ = CreateMaybeMessage< ::romabuf::NumVal >(GetArena());
  }
  return value_.num_val_;
}
inline ::romabuf::NumVal* PValue::mutable_num_val() {
  // @@protoc_insertion_point(field_mutable:romabuf.PValue.num_val)
  return _internal_mutable_num_val();
}

// .romabuf.StrVal str_val = 2;
inline bool PValue::_internal_has_str_val() const {
  return value_case() == kStrVal;
}
inline bool PValue::has_str_val() const {
  return _internal_has_str_val();
}
inline void PValue::set_has_str_val() {
  _oneof_case_[0] = kStrVal;
}
inline void PValue::clear_str_val() {
  if (_internal_has_str_val()) {
    if (GetArena() == nullptr) {
      delete value_.str_val_;
    }
    clear_has_value();
  }
}
inline ::romabuf::StrVal* PValue::release_str_val() {
  // @@protoc_insertion_point(field_release:romabuf.PValue.str_val)
  if (_internal_has_str_val()) {
    clear_has_value();
      ::romabuf::StrVal* temp = value_.str_val_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.str_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::StrVal& PValue::_internal_str_val() const {
  return _internal_has_str_val()
      ? *value_.str_val_
      : *reinterpret_cast< ::romabuf::StrVal*>(&::romabuf::_StrVal_default_instance_);
}
inline const ::romabuf::StrVal& PValue::str_val() const {
  // @@protoc_insertion_point(field_get:romabuf.PValue.str_val)
  return _internal_str_val();
}
inline ::romabuf::StrVal* PValue::unsafe_arena_release_str_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PValue.str_val)
  if (_internal_has_str_val()) {
    clear_has_value();
    ::romabuf::StrVal* temp = value_.str_val_;
    value_.str_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PValue::unsafe_arena_set_allocated_str_val(::romabuf::StrVal* str_val) {
  clear_value();
  if (str_val) {
    set_has_str_val();
    value_.str_val_ = str_val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PValue.str_val)
}
inline ::romabuf::StrVal* PValue::_internal_mutable_str_val() {
  if (!_internal_has_str_val()) {
    clear_value();
    set_has_str_val();
    value_.str_val_ = CreateMaybeMessage< ::romabuf::StrVal >(GetArena());
  }
  return value_.str_val_;
}
inline ::romabuf::StrVal* PValue::mutable_str_val() {
  // @@protoc_insertion_point(field_mutable:romabuf.PValue.str_val)
  return _internal_mutable_str_val();
}

// .romabuf.ERefVal eref_val = 3;
inline bool PValue::_internal_has_eref_val() const {
  return value_case() == kErefVal;
}
inline bool PValue::has_eref_val() const {
  return _internal_has_eref_val();
}
inline void PValue::set_has_eref_val() {
  _oneof_case_[0] = kErefVal;
}
inline void PValue::clear_eref_val() {
  if (_internal_has_eref_val()) {
    if (GetArena() == nullptr) {
      delete value_.eref_val_;
    }
    clear_has_value();
  }
}
inline ::romabuf::ERefVal* PValue::release_eref_val() {
  // @@protoc_insertion_point(field_release:romabuf.PValue.eref_val)
  if (_internal_has_eref_val()) {
    clear_has_value();
      ::romabuf::ERefVal* temp = value_.eref_val_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.eref_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::ERefVal& PValue::_internal_eref_val() const {
  return _internal_has_eref_val()
      ? *value_.eref_val_
      : *reinterpret_cast< ::romabuf::ERefVal*>(&::romabuf::_ERefVal_default_instance_);
}
inline const ::romabuf::ERefVal& PValue::eref_val() const {
  // @@protoc_insertion_point(field_get:romabuf.PValue.eref_val)
  return _internal_eref_val();
}
inline ::romabuf::ERefVal* PValue::unsafe_arena_release_eref_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PValue.eref_val)
  if (_internal_has_eref_val()) {
    clear_has_value();
    ::romabuf::ERefVal* temp = value_.eref_val_;
    value_.eref_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PValue::unsafe_arena_set_allocated_eref_val(::romabuf::ERefVal* eref_val) {
  clear_value();
  if (eref_val) {
    set_has_eref_val();
    value_.eref_val_ = eref_val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PValue.eref_val)
}
inline ::romabuf::ERefVal* PValue::_internal_mutable_eref_val() {
  if (!_internal_has_eref_val()) {
    clear_value();
    set_has_eref_val();
    value_.eref_val_ = CreateMaybeMessage< ::romabuf::ERefVal >(GetArena());
  }
  return value_.eref_val_;
}
inline ::romabuf::ERefVal* PValue::mutable_eref_val() {
  // @@protoc_insertion_point(field_mutable:romabuf.PValue.eref_val)
  return _internal_mutable_eref_val();
}

inline bool PValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void PValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline PValue::ValueCase PValue::value_case() const {
  return PValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PleromaMessage

// .romabuf.Call call = 1;
inline bool PleromaMessage::_internal_has_call() const {
  return msg_case() == kCall;
}
inline bool PleromaMessage::has_call() const {
  return _internal_has_call();
}
inline void PleromaMessage::set_has_call() {
  _oneof_case_[0] = kCall;
}
inline void PleromaMessage::clear_call() {
  if (_internal_has_call()) {
    if (GetArena() == nullptr) {
      delete msg_.call_;
    }
    clear_has_msg();
  }
}
inline ::romabuf::Call* PleromaMessage::release_call() {
  // @@protoc_insertion_point(field_release:romabuf.PleromaMessage.call)
  if (_internal_has_call()) {
    clear_has_msg();
      ::romabuf::Call* temp = msg_.call_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::Call& PleromaMessage::_internal_call() const {
  return _internal_has_call()
      ? *msg_.call_
      : *reinterpret_cast< ::romabuf::Call*>(&::romabuf::_Call_default_instance_);
}
inline const ::romabuf::Call& PleromaMessage::call() const {
  // @@protoc_insertion_point(field_get:romabuf.PleromaMessage.call)
  return _internal_call();
}
inline ::romabuf::Call* PleromaMessage::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PleromaMessage.call)
  if (_internal_has_call()) {
    clear_has_msg();
    ::romabuf::Call* temp = msg_.call_;
    msg_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PleromaMessage::unsafe_arena_set_allocated_call(::romabuf::Call* call) {
  clear_msg();
  if (call) {
    set_has_call();
    msg_.call_ = call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PleromaMessage.call)
}
inline ::romabuf::Call* PleromaMessage::_internal_mutable_call() {
  if (!_internal_has_call()) {
    clear_msg();
    set_has_call();
    msg_.call_ = CreateMaybeMessage< ::romabuf::Call >(GetArena());
  }
  return msg_.call_;
}
inline ::romabuf::Call* PleromaMessage::mutable_call() {
  // @@protoc_insertion_point(field_mutable:romabuf.PleromaMessage.call)
  return _internal_mutable_call();
}

// .romabuf.AnnouncePeer announce_peer = 2;
inline bool PleromaMessage::_internal_has_announce_peer() const {
  return msg_case() == kAnnouncePeer;
}
inline bool PleromaMessage::has_announce_peer() const {
  return _internal_has_announce_peer();
}
inline void PleromaMessage::set_has_announce_peer() {
  _oneof_case_[0] = kAnnouncePeer;
}
inline void PleromaMessage::clear_announce_peer() {
  if (_internal_has_announce_peer()) {
    if (GetArena() == nullptr) {
      delete msg_.announce_peer_;
    }
    clear_has_msg();
  }
}
inline ::romabuf::AnnouncePeer* PleromaMessage::release_announce_peer() {
  // @@protoc_insertion_point(field_release:romabuf.PleromaMessage.announce_peer)
  if (_internal_has_announce_peer()) {
    clear_has_msg();
      ::romabuf::AnnouncePeer* temp = msg_.announce_peer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.announce_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::AnnouncePeer& PleromaMessage::_internal_announce_peer() const {
  return _internal_has_announce_peer()
      ? *msg_.announce_peer_
      : *reinterpret_cast< ::romabuf::AnnouncePeer*>(&::romabuf::_AnnouncePeer_default_instance_);
}
inline const ::romabuf::AnnouncePeer& PleromaMessage::announce_peer() const {
  // @@protoc_insertion_point(field_get:romabuf.PleromaMessage.announce_peer)
  return _internal_announce_peer();
}
inline ::romabuf::AnnouncePeer* PleromaMessage::unsafe_arena_release_announce_peer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PleromaMessage.announce_peer)
  if (_internal_has_announce_peer()) {
    clear_has_msg();
    ::romabuf::AnnouncePeer* temp = msg_.announce_peer_;
    msg_.announce_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PleromaMessage::unsafe_arena_set_allocated_announce_peer(::romabuf::AnnouncePeer* announce_peer) {
  clear_msg();
  if (announce_peer) {
    set_has_announce_peer();
    msg_.announce_peer_ = announce_peer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PleromaMessage.announce_peer)
}
inline ::romabuf::AnnouncePeer* PleromaMessage::_internal_mutable_announce_peer() {
  if (!_internal_has_announce_peer()) {
    clear_msg();
    set_has_announce_peer();
    msg_.announce_peer_ = CreateMaybeMessage< ::romabuf::AnnouncePeer >(GetArena());
  }
  return msg_.announce_peer_;
}
inline ::romabuf::AnnouncePeer* PleromaMessage::mutable_announce_peer() {
  // @@protoc_insertion_point(field_mutable:romabuf.PleromaMessage.announce_peer)
  return _internal_mutable_announce_peer();
}

// .romabuf.AssignClusterInfo assign_cluster_info = 3;
inline bool PleromaMessage::_internal_has_assign_cluster_info() const {
  return msg_case() == kAssignClusterInfo;
}
inline bool PleromaMessage::has_assign_cluster_info() const {
  return _internal_has_assign_cluster_info();
}
inline void PleromaMessage::set_has_assign_cluster_info() {
  _oneof_case_[0] = kAssignClusterInfo;
}
inline void PleromaMessage::clear_assign_cluster_info() {
  if (_internal_has_assign_cluster_info()) {
    if (GetArena() == nullptr) {
      delete msg_.assign_cluster_info_;
    }
    clear_has_msg();
  }
}
inline ::romabuf::AssignClusterInfo* PleromaMessage::release_assign_cluster_info() {
  // @@protoc_insertion_point(field_release:romabuf.PleromaMessage.assign_cluster_info)
  if (_internal_has_assign_cluster_info()) {
    clear_has_msg();
      ::romabuf::AssignClusterInfo* temp = msg_.assign_cluster_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.assign_cluster_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::AssignClusterInfo& PleromaMessage::_internal_assign_cluster_info() const {
  return _internal_has_assign_cluster_info()
      ? *msg_.assign_cluster_info_
      : *reinterpret_cast< ::romabuf::AssignClusterInfo*>(&::romabuf::_AssignClusterInfo_default_instance_);
}
inline const ::romabuf::AssignClusterInfo& PleromaMessage::assign_cluster_info() const {
  // @@protoc_insertion_point(field_get:romabuf.PleromaMessage.assign_cluster_info)
  return _internal_assign_cluster_info();
}
inline ::romabuf::AssignClusterInfo* PleromaMessage::unsafe_arena_release_assign_cluster_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PleromaMessage.assign_cluster_info)
  if (_internal_has_assign_cluster_info()) {
    clear_has_msg();
    ::romabuf::AssignClusterInfo* temp = msg_.assign_cluster_info_;
    msg_.assign_cluster_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PleromaMessage::unsafe_arena_set_allocated_assign_cluster_info(::romabuf::AssignClusterInfo* assign_cluster_info) {
  clear_msg();
  if (assign_cluster_info) {
    set_has_assign_cluster_info();
    msg_.assign_cluster_info_ = assign_cluster_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PleromaMessage.assign_cluster_info)
}
inline ::romabuf::AssignClusterInfo* PleromaMessage::_internal_mutable_assign_cluster_info() {
  if (!_internal_has_assign_cluster_info()) {
    clear_msg();
    set_has_assign_cluster_info();
    msg_.assign_cluster_info_ = CreateMaybeMessage< ::romabuf::AssignClusterInfo >(GetArena());
  }
  return msg_.assign_cluster_info_;
}
inline ::romabuf::AssignClusterInfo* PleromaMessage::mutable_assign_cluster_info() {
  // @@protoc_insertion_point(field_mutable:romabuf.PleromaMessage.assign_cluster_info)
  return _internal_mutable_assign_cluster_info();
}

// .romabuf.HostInfo host_info = 4;
inline bool PleromaMessage::_internal_has_host_info() const {
  return msg_case() == kHostInfo;
}
inline bool PleromaMessage::has_host_info() const {
  return _internal_has_host_info();
}
inline void PleromaMessage::set_has_host_info() {
  _oneof_case_[0] = kHostInfo;
}
inline void PleromaMessage::clear_host_info() {
  if (_internal_has_host_info()) {
    if (GetArena() == nullptr) {
      delete msg_.host_info_;
    }
    clear_has_msg();
  }
}
inline ::romabuf::HostInfo* PleromaMessage::release_host_info() {
  // @@protoc_insertion_point(field_release:romabuf.PleromaMessage.host_info)
  if (_internal_has_host_info()) {
    clear_has_msg();
      ::romabuf::HostInfo* temp = msg_.host_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.host_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::romabuf::HostInfo& PleromaMessage::_internal_host_info() const {
  return _internal_has_host_info()
      ? *msg_.host_info_
      : *reinterpret_cast< ::romabuf::HostInfo*>(&::romabuf::_HostInfo_default_instance_);
}
inline const ::romabuf::HostInfo& PleromaMessage::host_info() const {
  // @@protoc_insertion_point(field_get:romabuf.PleromaMessage.host_info)
  return _internal_host_info();
}
inline ::romabuf::HostInfo* PleromaMessage::unsafe_arena_release_host_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.PleromaMessage.host_info)
  if (_internal_has_host_info()) {
    clear_has_msg();
    ::romabuf::HostInfo* temp = msg_.host_info_;
    msg_.host_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PleromaMessage::unsafe_arena_set_allocated_host_info(::romabuf::HostInfo* host_info) {
  clear_msg();
  if (host_info) {
    set_has_host_info();
    msg_.host_info_ = host_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.PleromaMessage.host_info)
}
inline ::romabuf::HostInfo* PleromaMessage::_internal_mutable_host_info() {
  if (!_internal_has_host_info()) {
    clear_msg();
    set_has_host_info();
    msg_.host_info_ = CreateMaybeMessage< ::romabuf::HostInfo >(GetArena());
  }
  return msg_.host_info_;
}
inline ::romabuf::HostInfo* PleromaMessage::mutable_host_info() {
  // @@protoc_insertion_point(field_mutable:romabuf.PleromaMessage.host_info)
  return _internal_mutable_host_info();
}

inline bool PleromaMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void PleromaMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline PleromaMessage::MsgCase PleromaMessage::msg_case() const {
  return PleromaMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Call

// required int32 node_id = 1;
inline bool Call::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Call::has_node_id() const {
  return _internal_has_node_id();
}
inline void Call::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.node_id)
  return _internal_node_id();
}
inline void Call::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_id_ = value;
}
inline void Call::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.node_id)
}

// required int32 vat_id = 2;
inline bool Call::_internal_has_vat_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Call::has_vat_id() const {
  return _internal_has_vat_id();
}
inline void Call::clear_vat_id() {
  vat_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_vat_id() const {
  return vat_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::vat_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.vat_id)
  return _internal_vat_id();
}
inline void Call::_internal_set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  vat_id_ = value;
}
inline void Call::set_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vat_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.vat_id)
}

// required int32 entity_id = 3;
inline bool Call::_internal_has_entity_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Call::has_entity_id() const {
  return _internal_has_entity_id();
}
inline void Call::clear_entity_id() {
  entity_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::entity_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.entity_id)
  return _internal_entity_id();
}
inline void Call::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  entity_id_ = value;
}
inline void Call::set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.entity_id)
}

// required string function_id = 4;
inline bool Call::_internal_has_function_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Call::has_function_id() const {
  return _internal_has_function_id();
}
inline void Call::clear_function_id() {
  function_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Call::function_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.function_id)
  return _internal_function_id();
}
inline void Call::set_function_id(const std::string& value) {
  _internal_set_function_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.function_id)
}
inline std::string* Call::mutable_function_id() {
  // @@protoc_insertion_point(field_mutable:romabuf.Call.function_id)
  return _internal_mutable_function_id();
}
inline const std::string& Call::_internal_function_id() const {
  return function_id_.Get();
}
inline void Call::_internal_set_function_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Call::set_function_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  function_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.Call.function_id)
}
inline void Call::set_function_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.Call.function_id)
}
inline void Call::set_function_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.Call.function_id)
}
inline std::string* Call::_internal_mutable_function_id() {
  _has_bits_[0] |= 0x00000001u;
  return function_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Call::release_function_id() {
  // @@protoc_insertion_point(field_release:romabuf.Call.function_id)
  if (!_internal_has_function_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return function_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Call::set_allocated_function_id(std::string* function_id) {
  if (function_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.Call.function_id)
}
inline std::string* Call::unsafe_arena_release_function_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.Call.function_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return function_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Call::unsafe_arena_set_allocated_function_id(
    std::string* function_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (function_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      function_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.Call.function_id)
}

// required int32 src_node_id = 5;
inline bool Call::_internal_has_src_node_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Call::has_src_node_id() const {
  return _internal_has_src_node_id();
}
inline void Call::clear_src_node_id() {
  src_node_id_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_src_node_id() const {
  return src_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::src_node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.src_node_id)
  return _internal_src_node_id();
}
inline void Call::_internal_set_src_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  src_node_id_ = value;
}
inline void Call::set_src_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.src_node_id)
}

// required int32 src_vat_id = 6;
inline bool Call::_internal_has_src_vat_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Call::has_src_vat_id() const {
  return _internal_has_src_vat_id();
}
inline void Call::clear_src_vat_id() {
  src_vat_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_src_vat_id() const {
  return src_vat_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::src_vat_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.src_vat_id)
  return _internal_src_vat_id();
}
inline void Call::_internal_set_src_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  src_vat_id_ = value;
}
inline void Call::set_src_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_vat_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.src_vat_id)
}

// required int32 src_entity_id = 7;
inline bool Call::_internal_has_src_entity_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Call::has_src_entity_id() const {
  return _internal_has_src_entity_id();
}
inline void Call::clear_src_entity_id() {
  src_entity_id_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_src_entity_id() const {
  return src_entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::src_entity_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.src_entity_id)
  return _internal_src_entity_id();
}
inline void Call::_internal_set_src_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  src_entity_id_ = value;
}
inline void Call::set_src_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_src_entity_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.src_entity_id)
}

// required string src_function_id = 8;
inline bool Call::_internal_has_src_function_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Call::has_src_function_id() const {
  return _internal_has_src_function_id();
}
inline void Call::clear_src_function_id() {
  src_function_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Call::src_function_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.src_function_id)
  return _internal_src_function_id();
}
inline void Call::set_src_function_id(const std::string& value) {
  _internal_set_src_function_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.src_function_id)
}
inline std::string* Call::mutable_src_function_id() {
  // @@protoc_insertion_point(field_mutable:romabuf.Call.src_function_id)
  return _internal_mutable_src_function_id();
}
inline const std::string& Call::_internal_src_function_id() const {
  return src_function_id_.Get();
}
inline void Call::_internal_set_src_function_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  src_function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Call::set_src_function_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  src_function_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.Call.src_function_id)
}
inline void Call::set_src_function_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  src_function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.Call.src_function_id)
}
inline void Call::set_src_function_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  src_function_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.Call.src_function_id)
}
inline std::string* Call::_internal_mutable_src_function_id() {
  _has_bits_[0] |= 0x00000002u;
  return src_function_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Call::release_src_function_id() {
  // @@protoc_insertion_point(field_release:romabuf.Call.src_function_id)
  if (!_internal_has_src_function_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return src_function_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Call::set_allocated_src_function_id(std::string* src_function_id) {
  if (src_function_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_function_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_function_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.Call.src_function_id)
}
inline std::string* Call::unsafe_arena_release_src_function_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.Call.src_function_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return src_function_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Call::unsafe_arena_set_allocated_src_function_id(
    std::string* src_function_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (src_function_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_function_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      src_function_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.Call.src_function_id)
}

// required bool response = 9;
inline bool Call::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Call::has_response() const {
  return _internal_has_response();
}
inline void Call::clear_response() {
  response_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Call::_internal_response() const {
  return response_;
}
inline bool Call::response() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.response)
  return _internal_response();
}
inline void Call::_internal_set_response(bool value) {
  _has_bits_[0] |= 0x00000100u;
  response_ = value;
}
inline void Call::set_response(bool value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.response)
}

// required int32 promise_id = 10;
inline bool Call::_internal_has_promise_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Call::has_promise_id() const {
  return _internal_has_promise_id();
}
inline void Call::clear_promise_id() {
  promise_id_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::_internal_promise_id() const {
  return promise_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Call::promise_id() const {
  // @@protoc_insertion_point(field_get:romabuf.Call.promise_id)
  return _internal_promise_id();
}
inline void Call::_internal_set_promise_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  promise_id_ = value;
}
inline void Call::set_promise_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_promise_id(value);
  // @@protoc_insertion_point(field_set:romabuf.Call.promise_id)
}

// repeated .romabuf.PValue pvalues = 11;
inline int Call::_internal_pvalues_size() const {
  return pvalues_.size();
}
inline int Call::pvalues_size() const {
  return _internal_pvalues_size();
}
inline void Call::clear_pvalues() {
  pvalues_.Clear();
}
inline ::romabuf::PValue* Call::mutable_pvalues(int index) {
  // @@protoc_insertion_point(field_mutable:romabuf.Call.pvalues)
  return pvalues_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::PValue >*
Call::mutable_pvalues() {
  // @@protoc_insertion_point(field_mutable_list:romabuf.Call.pvalues)
  return &pvalues_;
}
inline const ::romabuf::PValue& Call::_internal_pvalues(int index) const {
  return pvalues_.Get(index);
}
inline const ::romabuf::PValue& Call::pvalues(int index) const {
  // @@protoc_insertion_point(field_get:romabuf.Call.pvalues)
  return _internal_pvalues(index);
}
inline ::romabuf::PValue* Call::_internal_add_pvalues() {
  return pvalues_.Add();
}
inline ::romabuf::PValue* Call::add_pvalues() {
  // @@protoc_insertion_point(field_add:romabuf.Call.pvalues)
  return _internal_add_pvalues();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::PValue >&
Call::pvalues() const {
  // @@protoc_insertion_point(field_list:romabuf.Call.pvalues)
  return pvalues_;
}

// -------------------------------------------------------------------

// AnnouncePeer

// required string address = 1;
inline bool AnnouncePeer::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnnouncePeer::has_address() const {
  return _internal_has_address();
}
inline void AnnouncePeer::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AnnouncePeer::address() const {
  // @@protoc_insertion_point(field_get:romabuf.AnnouncePeer.address)
  return _internal_address();
}
inline void AnnouncePeer::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:romabuf.AnnouncePeer.address)
}
inline std::string* AnnouncePeer::mutable_address() {
  // @@protoc_insertion_point(field_mutable:romabuf.AnnouncePeer.address)
  return _internal_mutable_address();
}
inline const std::string& AnnouncePeer::_internal_address() const {
  return address_.Get();
}
inline void AnnouncePeer::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AnnouncePeer::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.AnnouncePeer.address)
}
inline void AnnouncePeer::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.AnnouncePeer.address)
}
inline void AnnouncePeer::set_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.AnnouncePeer.address)
}
inline std::string* AnnouncePeer::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AnnouncePeer::release_address() {
  // @@protoc_insertion_point(field_release:romabuf.AnnouncePeer.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AnnouncePeer::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.AnnouncePeer.address)
}
inline std::string* AnnouncePeer::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.AnnouncePeer.address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AnnouncePeer::unsafe_arena_set_allocated_address(
    std::string* address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.AnnouncePeer.address)
}

// required uint32 port = 2;
inline bool AnnouncePeer::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AnnouncePeer::has_port() const {
  return _internal_has_port();
}
inline void AnnouncePeer::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnnouncePeer::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnnouncePeer::port() const {
  // @@protoc_insertion_point(field_get:romabuf.AnnouncePeer.port)
  return _internal_port();
}
inline void AnnouncePeer::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void AnnouncePeer::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:romabuf.AnnouncePeer.port)
}

// -------------------------------------------------------------------

// AssignClusterInfo

// required uint32 node_id = 1;
inline bool AssignClusterInfo::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssignClusterInfo::has_node_id() const {
  return _internal_has_node_id();
}
inline void AssignClusterInfo::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignClusterInfo::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AssignClusterInfo::node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.AssignClusterInfo.node_id)
  return _internal_node_id();
}
inline void AssignClusterInfo::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_ = value;
}
inline void AssignClusterInfo::set_node_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.AssignClusterInfo.node_id)
}

// required int32 monad_node_id = 2;
inline bool AssignClusterInfo::_internal_has_monad_node_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssignClusterInfo::has_monad_node_id() const {
  return _internal_has_monad_node_id();
}
inline void AssignClusterInfo::clear_monad_node_id() {
  monad_node_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::_internal_monad_node_id() const {
  return monad_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::monad_node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.AssignClusterInfo.monad_node_id)
  return _internal_monad_node_id();
}
inline void AssignClusterInfo::_internal_set_monad_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  monad_node_id_ = value;
}
inline void AssignClusterInfo::set_monad_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_monad_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.AssignClusterInfo.monad_node_id)
}

// required int32 monad_vat_id = 3;
inline bool AssignClusterInfo::_internal_has_monad_vat_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AssignClusterInfo::has_monad_vat_id() const {
  return _internal_has_monad_vat_id();
}
inline void AssignClusterInfo::clear_monad_vat_id() {
  monad_vat_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::_internal_monad_vat_id() const {
  return monad_vat_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::monad_vat_id() const {
  // @@protoc_insertion_point(field_get:romabuf.AssignClusterInfo.monad_vat_id)
  return _internal_monad_vat_id();
}
inline void AssignClusterInfo::_internal_set_monad_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  monad_vat_id_ = value;
}
inline void AssignClusterInfo::set_monad_vat_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_monad_vat_id(value);
  // @@protoc_insertion_point(field_set:romabuf.AssignClusterInfo.monad_vat_id)
}

// required int32 monad_entity_id = 4;
inline bool AssignClusterInfo::_internal_has_monad_entity_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AssignClusterInfo::has_monad_entity_id() const {
  return _internal_has_monad_entity_id();
}
inline void AssignClusterInfo::clear_monad_entity_id() {
  monad_entity_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::_internal_monad_entity_id() const {
  return monad_entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AssignClusterInfo::monad_entity_id() const {
  // @@protoc_insertion_point(field_get:romabuf.AssignClusterInfo.monad_entity_id)
  return _internal_monad_entity_id();
}
inline void AssignClusterInfo::_internal_set_monad_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  monad_entity_id_ = value;
}
inline void AssignClusterInfo::set_monad_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_monad_entity_id(value);
  // @@protoc_insertion_point(field_set:romabuf.AssignClusterInfo.monad_entity_id)
}

// repeated .romabuf.HostInfo nodes = 5;
inline int AssignClusterInfo::_internal_nodes_size() const {
  return nodes_.size();
}
inline int AssignClusterInfo::nodes_size() const {
  return _internal_nodes_size();
}
inline void AssignClusterInfo::clear_nodes() {
  nodes_.Clear();
}
inline ::romabuf::HostInfo* AssignClusterInfo::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:romabuf.AssignClusterInfo.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::HostInfo >*
AssignClusterInfo::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:romabuf.AssignClusterInfo.nodes)
  return &nodes_;
}
inline const ::romabuf::HostInfo& AssignClusterInfo::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::romabuf::HostInfo& AssignClusterInfo::nodes(int index) const {
  // @@protoc_insertion_point(field_get:romabuf.AssignClusterInfo.nodes)
  return _internal_nodes(index);
}
inline ::romabuf::HostInfo* AssignClusterInfo::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::romabuf::HostInfo* AssignClusterInfo::add_nodes() {
  // @@protoc_insertion_point(field_add:romabuf.AssignClusterInfo.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::romabuf::HostInfo >&
AssignClusterInfo::nodes() const {
  // @@protoc_insertion_point(field_list:romabuf.AssignClusterInfo.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// Greeting

// required string node_name = 1;
inline bool Greeting::_internal_has_node_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Greeting::has_node_name() const {
  return _internal_has_node_name();
}
inline void Greeting::clear_node_name() {
  node_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Greeting::node_name() const {
  // @@protoc_insertion_point(field_get:romabuf.Greeting.node_name)
  return _internal_node_name();
}
inline void Greeting::set_node_name(const std::string& value) {
  _internal_set_node_name(value);
  // @@protoc_insertion_point(field_set:romabuf.Greeting.node_name)
}
inline std::string* Greeting::mutable_node_name() {
  // @@protoc_insertion_point(field_mutable:romabuf.Greeting.node_name)
  return _internal_mutable_node_name();
}
inline const std::string& Greeting::_internal_node_name() const {
  return node_name_.Get();
}
inline void Greeting::_internal_set_node_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Greeting::set_node_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:romabuf.Greeting.node_name)
}
inline void Greeting::set_node_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:romabuf.Greeting.node_name)
}
inline void Greeting::set_node_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:romabuf.Greeting.node_name)
}
inline std::string* Greeting::_internal_mutable_node_name() {
  _has_bits_[0] |= 0x00000001u;
  return node_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Greeting::release_node_name() {
  // @@protoc_insertion_point(field_release:romabuf.Greeting.node_name)
  if (!_internal_has_node_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Greeting::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:romabuf.Greeting.node_name)
}
inline std::string* Greeting::unsafe_arena_release_node_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:romabuf.Greeting.node_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return node_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Greeting::unsafe_arena_set_allocated_node_name(
    std::string* node_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (node_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      node_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:romabuf.Greeting.node_name)
}

// -------------------------------------------------------------------

// GreetingAck

// required int32 node_id = 1;
inline bool GreetingAck::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GreetingAck::has_node_id() const {
  return _internal_has_node_id();
}
inline void GreetingAck::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GreetingAck::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GreetingAck::node_id() const {
  // @@protoc_insertion_point(field_get:romabuf.GreetingAck.node_id)
  return _internal_node_id();
}
inline void GreetingAck::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_ = value;
}
inline void GreetingAck::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:romabuf.GreetingAck.node_id)
}

// -------------------------------------------------------------------

// LoadProgram

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace romabuf

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protoloma_2eproto
