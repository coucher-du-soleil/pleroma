use crate::ast;
use crate::lexer;
use crate::ast::{AstNode, BinOp, Distance, PType, CType, Hvalue, EntityDef, Module, Identifier};

use crate::common::{HashMap, String, Box, str, FromStr, Vec, ToString};

grammar;

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Inoc: (String, CType) = {
  <s:Symbol> ":" <c:CType> => (s, c)
}

DataDec: (String, CType) = {
  <s:Symbol> ":" <c:CType> ";" => (s, c)
}

InocList: Vec<(String, CType)> = {
  "{" Comma<Inoc> "}" => (<>).1
}

TypeSpec: CType = {
   ":" <c: CType> => c
}

Statement : Box<AstNode> = {
   "let" <s:Symbol> <t:TypeSpec?> "=" <e:Expr> ";" => Box::new(AstNode::DefinitionNode(s, Box::new(e))),
   <s:Symbol> "=" <e:Expr> ";" => Box::new(AstNode::AssignmentNode(ast::Identifier{original_sym: String::from(s), unique_sym: String::from("")}, Box::new(e))),
   Expr ";" => Box::new((<>).0),
   "↵" <e:Expr> ";" => Box::new(AstNode::Return(Box::new(e)))
}

ExprOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
}

Expr: AstNode = {
    <e1:Expr> <o:ExprOp> <e2:Num> => AstNode::OperatorNode(Box::new(e1), o, Box::new(AstNode::ValueNode(Hvalue::Pu8(e2 as u8)))),
    Num => AstNode::ValueNode(Hvalue::Pu8(<> as u8)),
    <s:Symbol> "(" <e:Expr*> ")" => AstNode::FunctionCall(ast::Identifier{original_sym: String::from(s), unique_sym: String::from("")}, e),
    <s:EntityIdentifier> "(" <e:Expr?> ")" => AstNode::EntityConstruction(ast::Identifier{original_sym: String::from(s), unique_sym: String::from("")}, Box::new(e)),
    <s:Symbol> "!" <f:Symbol> "(" <e:Expr?> ")" => AstNode::Message(ast::Identifier{original_sym: String::from(s), unique_sym: String::from("")}, Box::new(e)),
    PString => <>,
    Symbol => AstNode::Identifier(Identifier{original_sym: String::from(<>), unique_sym: String::from("")}),
    <e1:Expr> "⌜" <e2:Expr> "⌟" => AstNode::Index(Box::new(e1), Box::new(e2)),
    "[" <v:Comma<Expr>> "]" => AstNode::ValueNode(Hvalue::List(v)),
}

PString: AstNode = {
    "\"" <s:Symbol> "\"" => AstNode::ValueNode(Hvalue::PString(s))
}


Function: (String, Box<AstNode>) = {
    "δ" <f:Symbol> "(" <p:Comma<Inoc>> ")" <nn:ReturnType> <r:CType> "{" <b:Statement*> "}" => (f.clone(), Box::new(AstNode::Function{name: f, parameters: p, body: b, return_type: r}))
}

pub Import: String = {
  "~" <s:Symbol> ";" => s
  //"►"
}

pub Module: Module = {
  <ims: Import*> <ed:EntityDef*> => Module {imports: ims, entity_defs: ed.into_iter().collect()}
}

EntityDef: (String, AstNode) = {
    "ε" <s:Symbol> <i:InocList> "{" <d:DataDec*> <f:Function*> "}"=> (s.clone(), AstNode::EntityDef(EntityDef{name: String::from("hi"), inoculation_list: i, data_declarations: d, functions: f.into_iter().collect(), foreign_functions: HashMap::new()}))
}

PType: PType = {
  "u32" => PType::Pu32,
  "[" <c:CType> "]" => PType::List(Box::new(c)),
  <s:EntityIdentifier> => PType::Entity
}

CType: CType = {
  "far" <base_type:PType> => CType::Loc(<>),
  "loc" <base_type:PType> => CType::Far(<>),
  "aln" <base_type:PType> => CType::Alien(<>),
  <base_type: PType> => CType::Loc(<>),
  "void" => CType::Void
}

PDist: Distance = {
  "far" => Distance::Far,
  "loc" => Distance::Local
}

Num: u8 = {
    <Pu8> => <>
};

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        " " => lexer::Tok::Space,
        ":" => lexer::Tok::Colon,
        ";" => lexer::Tok::Semicolon,
        "{" => lexer::Tok::LeftBracket,
        "}" => lexer::Tok::RightBracket,
        "let" => lexer::Tok::Let,
        "=" => lexer::Tok::Equals,

        "↵" => lexer::Tok::ReturnKeyword,
        "+" => lexer::Tok::Plus,
        "-" => lexer::Tok::Minus,
        "*" => lexer::Tok::Times,
        "/" => lexer::Tok::Divide,

        "(" => lexer::Tok::LeftParen,
        ")" => lexer::Tok::RightParen,

        "⌜" => lexer::Tok::IndexLeft,
        "⌟" => lexer::Tok::IndexRight,

        "[" => lexer::Tok::LeftSquareBracket,
        "]" => lexer::Tok::RightSquareBracket,
        "\"" => lexer::Tok::QuotationMark,

        "ε" => lexer::Tok::Entity,
        "δ" => lexer::Tok::Function,
        ReturnType => lexer::Tok::ReturnType,
        "~" => lexer::Tok::Import,
        "," => lexer::Tok::Comma,
        "!" => lexer::Tok::Message,

        "\t" => lexer::Tok::Tab,
        "\n" => lexer::Tok::Linefeed,
        EntityIdentifier => lexer::Tok::EntityIdentifier { value: <String> },
        Symbol => lexer::Tok::Symbol { value: <String> },
        "[a-z][a-zA-Z]*" => lexer::Tok::StringToken { value: <String> },
        "[0-9]+" => lexer::Tok::Number,

        "u32" => lexer::Tok::Pu32,

        "far" => lexer::Tok::Far,

        "loc" => lexer::Tok::Loc,

        "aln" => lexer::Tok::Aln,

        "void" => lexer::Tok::Void,
        Pu8 => lexer::Tok::Pu8 {value : <u8> },
    }
}